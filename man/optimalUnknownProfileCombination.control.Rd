% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/singleHypothesisFunctions.R
\name{optimalUnknownProfileCombination.control}
\alias{optimalUnknownProfileCombination.control}
\title{'optimalUnknownProfileCombination' control function}
\usage{
optimalUnknownProfileCombination.control(numberOfPopulations = 4,
  populationSize = 10, numberOfIterations = 25,
  numberOfInnerIterations = 10, numberOfIterationsEqualMinMax = 10,
  fractionOfPopulationsMax = NULL, numberOfFittestIndividuals = 10,
  parentSelectionWindowSize = 5, allowParentSurvival = TRUE,
  crossoverProbability = NULL, mutationProbabilityLowerLimit = NULL,
  mutationProbabilityUpperLimit = 0.95, mutationIterations = 2,
  mutationDegreesOfFreedom = 100, mutationDecayRate = 1/2,
  mutationDecay = NULL, fractionFittestIndividuals = 1,
  hillClimbingIterations = 2, convexMarkerImbalanceInterpolation = 0.8,
  tolerance = 1e-06, seed = NULL, trace = TRUE,
  simplifiedReturn = FALSE, numberOfThreads = 4,
  levelsOfStutterRecursion = 2, traceLimit = 100)
}
\arguments{
\item{numberOfPopulations}{The number of sub-populations.}

\item{populationSize}{The size of the sub-populations.}

\item{numberOfIterations}{The maximum number of (outer) iterations.}

\item{numberOfInnerIterations}{The number of inner iterations.}

\item{numberOfIterationsEqualMinMax}{The number of iterations with the number of sub-populations with the same 'largest' individual divided 'numberOfPopulations' less than or equal to 'fractionOfPopulationsMax'.}

\item{fractionOfPopulationsMax}{Fraction of the number of sub-populations with the same maximum needed before convergence counter initiates.}

\item{numberOfFittestIndividuals}{The number of unique individuals stored and returned.}

\item{parentSelectionWindowSize}{The size of the parent selecetion window.}

\item{allowParentSurvival}{Should parents be allowed to survive from iteration to iteration (TRUE/FALSE).}

\item{crossoverProbability}{The cross-over probability.}

\item{mutationProbabilityLowerLimit}{The lower limit on the probability of mutation.}

\item{mutationProbabilityUpperLimit}{The upper limit on the probability of mutation.}

\item{mutationIterations}{The number of iterations used in mutation stage (not currently in use).}

\item{mutationDegreesOfFreedom}{The degrees of freedom of the t-distribution used to create the mutation probabilities.}

\item{mutationDecayRate}{The rate of the decay of the mutation probability. Needed if 'mutationDecay' is 'NULL'.}

\item{mutationDecay}{The decay of the mutation probability to the lower limit.}

\item{fractionFittestIndividuals}{The fraction of the population forced to survive (not currently in use)}

\item{hillClimbingIterations}{The number of iterations each child or parent is hill climbed.}

\item{convexMarkerImbalanceInterpolation}{A fraction used to create a convex combination of the of MoM and the prior estimates of the marker imbalances.}

\item{tolerance}{Tolerance of internal log-likelihood maximisation (can be vector of upto size '4').}

\item{seed}{A seed for the c++ implementaion.}

\item{trace}{Show trace (TRUE/FALSE)?}

\item{simplifiedReturn}{Should the returned list be simplified (TRUE/FALSE)?}

\item{numberOfThreads}{The maximum number of threads allowed.}

\item{levelsOfStutterRecursion}{The number of layers used in the stutter recursion.}

\item{traceLimit}{Limits the trace of the parallel implementation.}
}
\value{
A list containing all relevant parameters.
}
\description{
A function setting all relavent parameters used internally in the \link{LR}-function.
}
\details{
If 'numberOfFittestIndividuals' is 'NULL' (default), then the number of fittest individuals stored across iterations is ceiling(0.1 * 'populationSize'). If the number of populations is larger than 1, then 'populationSize' refers to the sub-population size. Thus, it is recommended this parameter is set if running multiple populations.

If 'fractionOfPopulationsMax' is 'NULL' (default), it is set as the maximum of 0.05 and 1 / 'numberOfPopulations'.

If 'mutationDecay' is 'NULL' (default) and if the number of populations is 1, then it is set as seq(0, by = mutationDecayRate * 4 / (numberOfIterations), length.out = numberOfIterations). If the population size is larger than 1 the parameter 'numberOfIterations' is replaced by 'numberOfIterations * numberOfInnerIterations' i.e. the total number of iterations.

If 'seed' is 'NULL', then it is sampled from uniformly from [1; 10^6].
}
